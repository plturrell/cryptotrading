#!/usr/bin/env python3
"""
ğŸ§ª Comprehensive test of the secret management system
Tests all components to ensure everything works together
"""

import os
import sys
import json
from pathlib import Path

def test_basic_secret_operations():
    """Test basic secret storage and retrieval"""
    print("ğŸ§ª Testing basic secret operations...")
    
    try:
        from config.secret_manager import setup_secret_manager
        
        sm = setup_secret_manager()
        
        # Test storing a secret
        test_key = "TEST_INTEGRATION_KEY"
        test_value = "test_integration_value_12345"
        
        success = sm.store_secret(test_key, test_value, "testing")
        assert success, "Failed to store secret"
        print("   âœ… Secret storage works")
        
        # Test retrieving the secret
        retrieved_value = sm.get_secret(test_key)
        assert retrieved_value == test_value, f"Retrieved value mismatch: {retrieved_value} != {test_value}"
        print("   âœ… Secret retrieval works")
        
        # Test listing secrets
        secrets_list = sm.list_secrets()
        assert "testing" in secrets_list, "Testing category not found"
        assert test_key in secrets_list["testing"], "Test key not found in listing"
        print("   âœ… Secret listing works")
        
        # Clean up
        sm.delete_secret(test_key)
        print("   âœ… Secret deletion works")
        
        return True
        
    except Exception as e:
        print(f"   âŒ Basic operations failed: {e}")
        return False

def test_configuration_integration():
    """Test configuration module integration"""
    print("ğŸ§ª Testing configuration integration...")
    
    try:
        from config import get_config, get_secret
        
        # Test getting complete config
        config = get_config()
        assert isinstance(config, dict), "Config should be a dictionary"
        assert "environment" in config, "Environment should be in config"
        print("   âœ… Configuration loading works")
        
        # Test getting specific secret
        secret_value = get_secret("FRED_API_KEY")  # We know this exists from migration
        assert secret_value is not None, "Should find FRED_API_KEY"
        print("   âœ… Individual secret access works")
        
        # Test fallback
        fallback_value = get_secret("NON_EXISTENT_KEY", default="fallback")
        assert fallback_value == "fallback", "Fallback should work"
        print("   âœ… Fallback mechanism works")
        
        return True
        
    except Exception as e:
        print(f"   âŒ Configuration integration failed: {e}")
        return False

def test_vercel_export():
    """Test Vercel export functionality"""
    print("ğŸ§ª Testing Vercel export...")
    
    try:
        from config.secret_manager import setup_secret_manager
        
        sm = setup_secret_manager()
        
        # Test Vercel export
        vercel_export = sm.export_for_vercel()
        assert "secrets" in vercel_export, "Export should contain secrets"
        assert "cli_commands" in vercel_export, "Export should contain CLI commands"
        assert len(vercel_export["secrets"]) > 0, "Should have some secrets to export"
        print(f"   âœ… Vercel export works ({len(vercel_export['secrets'])} secrets)")
        
        # Test CLI commands format
        cli_commands = vercel_export["cli_commands"]
        assert len(cli_commands) > 0, "Should have CLI commands"
        assert all("vercel env add" in cmd for cmd in cli_commands), "All commands should be vercel env add"
        print("   âœ… CLI commands generation works")
        
        return True
        
    except Exception as e:
        print(f"   âŒ Vercel export failed: {e}")
        return False

def test_env_file_generation():
    """Test .env file generation"""
    print("ğŸ§ª Testing .env file generation...")
    
    try:
        from config.secret_manager import setup_secret_manager
        
        sm = setup_secret_manager()
        
        # Test generating a development .env file
        test_env_file = ".env.test"
        success = sm.generate_env_file(
            template_file=".env.example",
            output_file=test_env_file,
            environment="development"
        )
        
        assert success, "Env file generation should succeed"
        
        # Check if file was created
        test_env_path = Path(test_env_file)
        assert test_env_path.exists(), "Test env file should exist"
        
        # Check file content
        with open(test_env_path, 'r') as f:
            content = f.read()
        
        assert "Generated by SecretManager" in content, "Should have generation header"
        assert "GROK4_API_KEY=" in content, "Should contain GROK4_API_KEY"
        print("   âœ… Env file generation works")
        
        # Clean up
        test_env_path.unlink()
        print("   âœ… Test cleanup completed")
        
        return True
        
    except Exception as e:
        print(f"   âŒ Env file generation failed: {e}")
        return False

def test_secret_validation():
    """Test secret validation"""
    print("ğŸ§ª Testing secret validation...")
    
    try:
        from config.secret_manager import validate_deployment_secrets
        
        validation = validate_deployment_secrets()
        assert isinstance(validation, dict), "Validation should return a dict"
        assert "valid" in validation, "Should have valid field"
        assert "total_secrets" in validation, "Should have total_secrets field"
        assert "categories" in validation, "Should have categories field"
        
        print(f"   âœ… Validation works (Total: {validation['total_secrets']} secrets)")
        
        if not validation["valid"]:
            print(f"   âš ï¸  Missing required secrets: {validation.get('missing', [])}")
        
        return True
        
    except Exception as e:
        print(f"   âŒ Secret validation failed: {e}")
        return False

def test_file_permissions():
    """Test that secret files have proper permissions"""
    print("ğŸ§ª Testing file permissions...")
    
    try:
        secret_files = [
            "config/.encryption_key",
            "config/secrets.encrypted"
        ]
        
        for file_path in secret_files:
            path = Path(file_path)
            if path.exists():
                stat = path.stat()
                permissions = oct(stat.st_mode)[-3:]
                
                # Check that file is not world-readable
                assert permissions[2] == '0', f"File {file_path} should not be world-readable (permissions: {permissions})"
                print(f"   âœ… {file_path} has secure permissions ({permissions})")
        
        return True
        
    except Exception as e:
        print(f"   âŒ Permission check failed: {e}")
        return False

def test_migration_completeness():
    """Test that migration was complete"""
    print("ğŸ§ª Testing migration completeness...")
    
    try:
        from config.secret_manager import setup_secret_manager
        
        sm = setup_secret_manager()
        secrets_list = sm.list_secrets()
        
        # Check for key secrets that should have been migrated
        expected_keys = [
            "FRED_API_KEY",
            "DATABASE_URL", 
            "AI_GATEWAY_API_KEY",
            "PERPLEXITY_API_KEY"
        ]
        
        found_keys = []
        for category, keys in secrets_list.items():
            found_keys.extend(keys)
        
        missing_keys = [key for key in expected_keys if key not in found_keys]
        
        if missing_keys:
            print(f"   âš ï¸  Missing expected keys: {missing_keys}")
        else:
            print("   âœ… All expected keys found")
        
        print(f"   ğŸ“Š Total categories: {len(secrets_list)}")
        print(f"   ğŸ“Š Total secrets: {sum(len(keys) for keys in secrets_list.values())}")
        
        return len(missing_keys) == 0
        
    except Exception as e:
        print(f"   âŒ Migration completeness check failed: {e}")
        return False

def generate_test_report(results):
    """Generate a test report"""
    total_tests = len(results)
    passed_tests = sum(results.values())
    
    print("\n" + "=" * 60)
    print("ğŸ§ª SECRET MANAGEMENT SYSTEM TEST REPORT")
    print("=" * 60)
    
    print(f"ğŸ“Š Test Summary: {passed_tests}/{total_tests} tests passed")
    print()
    
    for test_name, passed in results.items():
        status = "âœ… PASS" if passed else "âŒ FAIL"
        print(f"   {status} {test_name}")
    
    print()
    
    if passed_tests == total_tests:
        print("ğŸ‰ ALL TESTS PASSED! Your secret management system is fully operational.")
        print()
        print("ğŸš€ Next Steps:")
        print("   1. Update production secrets with real values")
        print("   2. Deploy to Vercel: ./vercel_setup.sh")
        print("   3. Test full deployment: ./scripts/deploy_with_secrets.sh")
    else:
        print("âš ï¸  Some tests failed. Please review the output above.")
        print("   Consider running the migration again or checking file permissions.")
    
    print("=" * 60)

def main():
    """Run all tests"""
    print("ğŸ” SECRET MANAGEMENT SYSTEM - COMPREHENSIVE TEST")
    print("=" * 60)
    
    tests = {
        "Basic Secret Operations": test_basic_secret_operations,
        "Configuration Integration": test_configuration_integration,
        "Vercel Export": test_vercel_export,
        "Env File Generation": test_env_file_generation,
        "Secret Validation": test_secret_validation,
        "File Permissions": test_file_permissions,
        "Migration Completeness": test_migration_completeness
    }
    
    results = {}
    
    for test_name, test_function in tests.items():
        print(f"\nğŸ§ª Running: {test_name}")
        try:
            results[test_name] = test_function()
        except Exception as e:
            print(f"   âŒ Test failed with exception: {e}")
            results[test_name] = False
    
    generate_test_report(results)
    
    # Return exit code
    return 0 if all(results.values()) else 1

if __name__ == "__main__":
    exit_code = main()
    sys.exit(exit_code)
